import { Clock, Timestamp } from './Clock.js';
import { BaseJsonCRDT, SerializedBaseJsonCRDT } from './BaseJsonCRDT.js';
import type { CRDT, Diff, Update } from './CRDT.js';

export type SerializedJsonCRDT<O extends object> = {
    crdt: SerializedBaseJsonCRDT<O>;
    clock: Timestamp;
};

/*
CRDT implementation using a single counter to track updates.
This version has two methods, `applyUpdate` and `createUpdate`, which are used to update the data.
The counter is part of the class and is incremented everytime we create or apply an update.
*/
export class JsonCRDT<O extends object> implements CRDT<O> {
    private clock: Clock;
    private crdt: BaseJsonCRDT<O>;

    static fromSerialized<O extends object>(
        serialized: SerializedJsonCRDT<O>,
        nodeId?: number
    ): JsonCRDT<O> {
        const { crdt } = serialized;
        let { clock } = serialized;
        if (nodeId !== undefined) {
            clock = `${nodeId}-${Clock.getCount(clock)}`;
        }
        return new JsonCRDT(clock, crdt);
    }

    constructor(nodeId: number, data: O);
    constructor(timestamp: Timestamp, data: SerializedBaseJsonCRDT<O>);
    constructor(nodeIdOrTimestamp: number | Timestamp, data: O | SerializedBaseJsonCRDT<O>) {
        if (typeof nodeIdOrTimestamp === 'number' && typeof data === 'object') {
            // normal constructor
            this.crdt = new BaseJsonCRDT(data as O);
            this.clock = new Clock(nodeIdOrTimestamp, 0);
            return;
        } else if (
            typeof nodeIdOrTimestamp === 'string' &&
            Clock.validate(nodeIdOrTimestamp) &&
            'data' in data &&
            'timestamps' in data
        ) {
            // fromSerialized constructor
            this.crdt = BaseJsonCRDT.fromSerialized(data);
            this.clock = new Clock(nodeIdOrTimestamp);
            return;
        }
        throw new Error('JsonCRDT constructor called with invalid arguments');
    }

    /**
     * Apply an update to the CRDT. An update consists of a data diff and a timestamp.
     * @param update.diff The data diff to apply
     * @param update.timestamp The timestamp associated with the data diff
     */
    applyUpdate(update: Update<O>) {
        const { diff, timestamp } = update;
        // if (this.clock.nodeId === 1) {
        //     debugger;
        // }
        this.clock.update(timestamp);
        this.crdt.update(diff, timestamp);
    }

    /**
     * Apply an update to the CRDT. An update consists of a data diff and a timestamp.
     * @param update.diff The data diff to apply
     * @param update.timestamp The timestamp associated with the data diff
     */
    applyUpdates(updates: Update<O>[]) {
        for (const update of updates) {
            this.applyUpdate(update);
        }
    }

    /**
     * Applies the provided data diff to the CRDT and returns an update containing the diff and the associated timestamp.
     * The timestamp is generated by the incrementing the internal logical clock.
     * @param data The data diff to apply
     * @returns An update object that contains the applied data diff and the associated timestamp
     */
    createUpdate(diff: Diff<O>): Update<O> {
        const timestamp = this.clock.tick();
        this.crdt.update(diff, timestamp);
        return { diff, timestamp };
    }

    calculateDiff(
        newData: O,
        options?: {
            allowedKeys?: Set<string> | null;
            ignorePaths?: Set<string> | null;
        }
    ): Diff<O> {
        return BaseJsonCRDT.calculateDiff(this.crdt.data(), newData, options) as O;
    }

    data(): O {
        return this.crdt.data();
    }

    // timestamps(): O {
    //     return this.crdt.timestamps();
    // }

    serialize(): SerializedJsonCRDT<O> {
        return {
            crdt: this.crdt.serialize(),
            clock: this.clock.timestamp
        };
    }

    nodeId(): number {
        return this.clock.nodeId;
    }

    timestamp(): Timestamp {
        return Clock.max(this.crdt.timestamps()).timestamp;
    }

    counter(): number {
        return this.clock.count;
    }

    getLogs() {
        return this.crdt.getLogs();
    }

    printLogs(title?: string) {
        return this.crdt.printLogs(title);
    }
}
