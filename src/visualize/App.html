<div class="dw-create-visualize chart-editor">
    <div class="row vis-wrapper" use:scroll>
        <div class="span4 visconfig">
            <TabNav bind:tab {showChartPicker} />
            <div class="form-horizontal vis-options">
                {#if showChartPicker}
                <!-- Chart Type -->
                <div class:hide-smart="tab !== 'pick'">
                    <ChartPicker {visualizations} {visArchive} on:change="loadVis(event)" />
                </div>
                {/if}

                <!-- Refine -->
                <div class:hide-smart="tab !== 'refine'">
                    {#if visLoading}
                    <Loading />
                    {/if}
                    <svelte:component this="{Refine}" {tab} />
                </div>

                <!-- Annotate -->
                <div class:hide-smart="tab !== 'annotate'">
                    <Annotate />
                    {#if visLoading}
                    <Loading />
                    {/if}
                    <svelte:component this="{Annotate}" {tab} />
                </div>

                <!-- Design -->
                <div class:hide-smart="tab !== 'design'">
                    <Design />
                </div>

                <ButtonNav bind:tab {showChartPicker} />
            </div>
        </div>

        <div class="span8">
            <div
                class="vis-main"
                ref:main
                class:stickyBottom="stickyBottom"
                class:stickyTop="stickyTop"
            >
                <div id="iframe-wrapper" style="height: 500px; overflow: visible;">
                    <iframe src="/preview/{ $id }" id="iframe-vis"></iframe>
                </div>

                <div class="toolbar" style="margin-top: 90px;">
                    <Resizer />
                    <ColorblindCheck />
                </div>

                <div id="notifications"></div>
            </div>
        </div>
    </div>
</div>

<style>
    .vis-wrapper {
        position: relative;
    }

    .vis-main {
        position: absolute;
        top: 0;
        padding: 35px 0;
    }

    .vis-main.stickyBottom {
        position: absolute;
        top: auto;
        bottom: 0;
    }

    .vis-main.stickyTop {
        position: fixed;
        top: 0;
        bottom: auto;
    }
</style>

<script>
    /* globals dw, $  */
    import TabNav from './TabNav.html';
    import ButtonNav from './ButtonNav.html';
    import Empty from './Empty.html';
    import Annotate from './Annotate.html';
    import Design from './Design.html';
    import ChartPicker from './ChartPicker.html';
    import Loading from './Loading.html';
    import Resizer from './Resizer.html';
    import ColorblindCheck from './colorblind-check/ColorblindCheck.html';
    import { loadScript, loadStylesheet } from '@datawrapper/shared/fetch';

    export default {
        components: {
            TabNav,
            ButtonNav,
            Annotate,
            Design,
            ChartPicker,
            Loading,
            Resizer,
            ColorblindCheck
        },
        data() {
            return {
                tab: 'refine',
                showChartPicker: true,
                Refine: Empty,
                Annotate: Empty,
                visualizations: [],
                visArchive: [],
                visLoading: false,
                defaultVisType: '',
                stickyTop: false,
                stickyBottom: false
            };
        },
        actions: {
            scroll(wrapper) {
                const checkOffset = () => {
                    const { top, bottom } = wrapper.getBoundingClientRect();
                    const hasOffsetBottom = bottom < this.refs.main.scrollHeight;
                    this.set({
                        stickyTop: top < 0 && !hasOffsetBottom,
                        stickyBottom: hasOffsetBottom
                    });
                };

                window.addEventListener('scroll', checkOffset);

                return {
                    destroy() {
                        window.removeEventListener('scroll', checkOffset);
                    }
                };
            }
        },
        methods: {
            loadVis(id) {
                const { visArchive, visualizations } = this.get();
                const chart = this.store;
                const vis = [...visArchive, ...visualizations].find(v => v.id === id);
                this.set({ visLoading: true });
                if (!vis.controls) {
                    console.error('This visualization does not define new svelte controls');
                    return;
                }
                const { type } = chart.get();
                if (type !== id) {
                    chart.setMetadata('visualize.chart-type-set', true);
                    chart.set({
                        type: id
                    });
                }
                Promise.all([
                    loadScript(`/static/plugins/${vis.controls.js}`),
                    loadStylesheet(`/static/plugins/${vis.controls.css}`)
                ]).then(() => {
                    /* crazy workaround:
                     * since only the first requirejs call will fail with an
                     * a Mismatched anonymous define() modules error
                     * we'll just load the module twice
                     */
                    try {
                        require([vis.controls.amd], mod => {});
                    } catch (e) {}
                    require([vis.controls.amd], mod => {
                        this.set({
                            Refine: Empty,
                            Annotate: Empty
                        });
                        if (mod.migrate) {
                            const { metadata } = chart.get();
                            mod.migrate(id, metadata);
                            chart.set({ metadata });
                        }

                        // apply vis default metadata
                        const visualize = {
                            ...(vis.controls.defaults || {}),
                            ...chart.getMetadata('visualize', {})
                        };
                        chart.setMetadata('visualize', visualize);
                        chart.set({
                            visualization: vis
                        });

                        // determine if we automaticall switch to refine tab
                        // const { tab, defaultVisType } = this.get();
                        // const chartTypeSet =
                        //     chart.getMetadata('visualize.chart-type-set', false) ||
                        //     id !== defaultVisType;

                        // this.set({
                        //     tab: tab === 'pick' && chartTypeSet ? 'refine' : tab
                        // });

                        // dw.backend.once('vis-ready', () => {
                        // wait for chart preview
                        getContext(win => {
                            // set refine & annotate controls and switch tab
                            chart.set({ vis: win.__dw.vis });
                            this.set({
                                visLoading: false,
                                Refine: mod.Refine || Empty,
                                Annotate: mod.Annotate || Empty
                            });
                            dw.backend.fire('options-reloaded');
                        });
                        // });
                    });
                });
            }
        },
        oncreate() {
            if (['#pick', '#refine', '#annotate', '#design'].includes(window.location.hash)) {
                this.set({ tab: window.location.hash.substr(1) });
            }
            // load visualization
            const { type } = this.store.get();
            this.loadVis(type);

            var scrollFixCont = $('.scrollfix-cont');
            scrollFixCont.scrollToFixed({
                marginTop: 0,
                zIndex: 999,
                limit: function () {
                    // var sftop = scrollFixCont.offset().top;
                    var ftminsfh = $('footer.footer').offset().top - scrollFixCont.height() - 60;
                    // if (sftop > ftminsfh) return sftop+10;
                    return ftminsfh;
                }
            });
        }
    };

    function getContext(callback) {
        var win = $('#iframe-vis').get(0).contentWindow;
        var doc = $('#iframe-vis').get(0).contentDocument;
        if (!win || !win.__dw || !win.__dw.vis) {
            return setTimeout(function () {
                getContext(callback);
            }, 200);
        }
        callback(win, doc);
    }
</script>
